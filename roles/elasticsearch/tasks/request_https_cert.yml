---

- name: Install certbot (Debian-based systems)
  ansible.builtin.apt:
    name: certbot
    state: present
  when: ansible_os_family == 'Debian'
  become: true

- name: Install certbot (RedHat-based systems)
  ansible.builtin.yum:
    name: certbot
    state: present
  when: ansible_os_family == 'RedHat'
  become: true

- name: Check if certificate exists
  ansible.builtin.stat:
    path: "/etc/letsencrypt/live/{{ item }}/fullchain.pem"
  loop: "{{ elasticsearch_hosts }}"
  register: cert_exists

- name: Request HTTPS certificate if not present
  ansible.builtin.command:
    cmd: "certbot certonly --standalone -d {{ item[0] }} --register-unsafely-without-email --agree-tos"
  loop: "{{ elasticsearch_hosts | zip(cert_exists.results) | list }}"
  when: not item[1].stat.exists
  loop_control:
    label: "{{ item[0] }}"
  become: true
  register: cert_requested

- name: Local intermediate exists
  stat:
    path: "{{ elasticsearch_local_certs_dir }}/{{ elasticsearch_ca_intermediate }}"
  register: elastic_intermediate_ca_file

- name: Local root exists
  stat:
    path: "{{ elasticsearch_local_certs_dir }}/{{ elasticsearch_ca_root }}"
  register: elastic_root_ca_file

- name: Copy letsencrypt CA to local files
  ansible.builtin.copy:
    src: /etc/letsencrypt/live/{{ item }}/chain.pem
    dest: "{{ elasticsearch_local_certs_dir }}/{{ elasticsearch_ca_chain_name }}"
  loop: "{{ elasticsearch_hosts }}"
  notify:
    - check if elasticsearch is active
    - restart elasticsearch
    - wait elasticsearch to be ready

- name: Slurp the chain.pem content
  slurp:
    src: "{{ elasticsearch_local_certs_dir }}/{{ elasticsearch_ca_chain_name }}"
  register: slurped_chain

- name: Decode the chain content
  set_fact:
    chain_content: "{{ slurped_chain['content'] | b64decode | regex_replace('\r\n', '\n') }}"

- name: Split the chain content into individual certificates
  set_fact:
    certificates: "{{ chain_content.split('-----END CERTIFICATE-----') | select('search', 'CERTIFICATE') | list }}"

- name: Write the intermediate certificate to its own file
  copy:
    content: "{{ certificates[0] }}-----END CERTIFICATE-----\n"
    dest: "/tmp/{{ elasticsearch_ca_intermediate }}"

- name: Copy the intermediate CA file to local certs storage
  ansible.builtin.copy:
    src: "/tmp/{{ elasticsearch_ca_intermediate }}"
    dest: "{{ elasticsearch_local_certs_dir }}/{{ elasticsearch_ca_intermediate }}"
  when:
    - not elastic_intermediate_ca_file.stat.exists or elastic_intermediate_ca_file.stat.checksum != (lookup('file', "/tmp/" + elasticsearch_ca_intermediate) | hash('sha256'))
    - not elasticsearch_ca_intermediate_manually_provided

- name: Write the root certificate to its own file
  copy:
    content: "{{ certificates[1] }}-----END CERTIFICATE-----\n"
    dest: "/tmp/{{ elasticsearch_ca_root }}"

- name: Copy the root CA file to local certs storage
  ansible.builtin.copy:
    src: "/tmp/{{ elasticsearch_ca_root }}"
    dest: "{{ elasticsearch_local_certs_dir }}/{{ elasticsearch_ca_root }}"
  when:
    - not elastic_root_ca_file.stat.exists or elastic_root_ca_file.stat.checksum != (lookup('file', "/tmp/" + elasticsearch_ca_root) | hash('sha256'))
    - not elasticsearch_ca_root_manually_provided

- name: Check for missing intermediate certificate
  fail:
    msg: "elasticsearch_ca_intermediate_manually_provided is YES in config file, but root certificate is missing. Please provide it or disable this setting."
  when: 
    - not elastic_intermediate_ca_file.stat.exists
    - not elasticsearch_ca_intermediate_manually_provided

- name: Check for missing root certificate
  fail:
    msg: "elasticsearch_ca_root_manually_provided is YES in config file, but intermediate certificate is missing. Please provide it or disable this setting."
  when: 
    - not elastic_root_ca_file.stat.exists
    - not elasticsearch_ca_root_manually_provided

- name: cert HTTPS exists
  stat:
    path: "{{ elasticsearch_certs_dir}}/http.p12"
  register: https_file

- name: elastic CA exists
  stat:
    path: "{{ elasticsearch_certs_dir}}/{{ elasticsearch_ca_filename }}"
  register: ca_file

- name: Get issuer of the http.p12 certificate
  shell: "openssl pkcs12 -in {{ elasticsearch_certs_dir }}/http.p12 -passin pass:{{ elasticsearch_cert_password }} -nokeys -clcerts | openssl x509 -noout -issuer"
  register: https_issuer
  changed_when: false
  ignore_errors: true
  when: https_file.stat.exists and ca_file.stat.exists

- name: Get subject of the CA
  shell: "openssl pkcs12 -in {{ elasticsearch_certs_dir }}/{{ elasticsearch_ca_filename }} -passin pass:{{ elasticsearch_ca_password }} -nokeys -clcerts | openssl x509 -noout -subject"
  register: ca_subject
  changed_when: false
  ignore_errors: true
  when: https_file.stat.exists and ca_file.stat.exists

- name: Set fact for https cert issued by CA
  set_fact:
    https_cert_issued_by_ca: "{{ https_issuer.stdout == ca_subject.stdout }}"
  when: 
    - https_issuer.stdout is defined 
    - ca_subject.stdout is defined

# TODO: below task assumes that the password for both elasticsearch_cert_password and elasticsearch_http_password are the same. May need to split into two PKCS12 files
- name: Create PKCS12 file for new or missing certificates
  ansible.builtin.command:
    cmd: > 
      openssl pkcs12 -export 
      -in /etc/letsencrypt/live/{{ item[0] }}/fullchain.pem
      -inkey /etc/letsencrypt/live/{{ item[0] }}/privkey.pem
      -out /tmp/{{ item[0] }}.p12
      -name elasticsearch -passout pass:{{ elasticsearch_cert_password }}
  loop: "{{ elasticsearch_hosts | zip(cert_requested.results) | list }}"
  when: https_cert_issued_by_ca or item[1].changed
  become: true

- name: Copy new PKCS12 files to Elasticsearch certs directory (client https)
  ansible.builtin.copy:
    src: "/tmp/{{ item[0] }}.p12"
    dest: "{{ elasticsearch_certs_dir }}/{{ elasticsearch_cert_filename }}"
    owner: "{{ elasticsearch_user }}"
    group: "{{ elasticsearch_group }}"
    mode: 0644
  when: https_cert_issued_by_ca or item[1].changed
  loop: "{{ elasticsearch_hosts | zip(cert_requested.results) | list }}"
  become: true
  notify:
    - check if elasticsearch is active
    - restart elasticsearch
    - wait elasticsearch to be ready

- name: Copy new PKCS12 files to Elasticsearch certs directory (node https)
  ansible.builtin.copy:
    src: "/tmp/{{ item[0] }}.p12"
    dest: "{{ elasticsearch_certs_dir }}/http.p12"
    owner: "{{ elasticsearch_user }}"
    group: "{{ elasticsearch_group }}"
    mode: 0644
  when: https_cert_issued_by_ca or item[1].changed
  loop: "{{ elasticsearch_hosts | zip(cert_requested.results) | list }}"
  become: true
  notify:
    - check if elasticsearch is active
    - restart elasticsearch
    - wait elasticsearch to be ready

- name: Debug item[1].changed
  ansible.builtin.debug:
    msg: "Value of item[1].changed: {{ item[1].changed }}"
  loop: "{{ elasticsearch_hosts | zip(cert_requested.results) | list }}"

- name: Debug https_cert_issued_by_ca
  ansible.builtin.debug:
    msg: "Value of https_cert_issued_by_ca: {{ https_cert_issued_by_ca }}"

- name: Clean up temporary PKCS12 files
  ansible.builtin.file:
    path: "/tmp/{{ item }}.p12"
    state: absent
  loop: "{{ elasticsearch_hosts }}"
  become: true

- name: Copy the trusted CA to the elasticsearch config directory
  ansible.builtin.copy:
    src: "{{ elasticsearch_local_certs_dir }}/{{ elasticsearch_ca_chain_name }}"
    dest: "{{ elasticsearch_certs_dir }}/{{ elasticsearch_ca_chain_name }}"
  # loop: "{{ elasticsearch_certificate_authorities }}"
  become: true

- name: Create certbot post renewal hook
  ansible.builtin.copy:
    content: |
      #!/bin/bash
      DOMAIN=$1

      # Create PKCS12 file
      openssl pkcs12 -export \
        -in /etc/letsencrypt/live/$DOMAIN/fullchain.pem \
        -inkey /etc/letsencrypt/live/$DOMAIN/privkey.pem \
        -out /tmp/$DOMAIN.p12 \
        -name elasticsearch -passout pass:{{ elasticsearch_cert_password }}

      # Copy the PKCS12 file to Elasticsearch certs directory
      cp /tmp/$DOMAIN.p12 {{ elasticsearch_certs_dir }}/{{ elasticsearch_cert_filename }}.p12
      cp /tmp/$DOMAIN.p12 {{ elasticsearch_certs_dir }}/http.p12

      if [[ -f "/etc/logstash/certs" ]]; then
        cp /etc/letsencrypt/live/$DOMAIN/cert.pem /etc/logstash/certs/{{ elasticsearch_ca_chain_name }}
      fi
      if [[ -f "/etc/kibana/certs" ]]; then
        cp /etc/letsencrypt/live/$DOMAIN/cert.pem /etc/kibana/certs/{{ elasticsearch_ca_chain_name }}
      fi

      # Cleanup
      rm -f /tmp/$DOMAIN.p12

      # Restart Elasticsearch service
      systemctl restart elasticsearch
    dest: "/etc/letsencrypt/renewal-hooks/post/elasticsearch-renewal.sh"
    mode: '0755'
  become: true

# Ensure certbot timer is active and running
- name: Ensure certbot timer is active and running
  ansible.builtin.systemd:
    name: certbot.timer
    state: started
    enabled: true
  become: true

- name: Cleanup locally created temporary certificates 1/2
  file:
    path: "/tmp/{{ elasticsearch_ca_intermediate }}"
    state: absent
    
- name: Cleanup locally created temporary certificates 2/2
  file:
    path: "/tmp/{{ elasticsearch_ca_root }}"
    state: absent