
input {
    beats {
        port => 5044
        ssl_enabled => true
        ssl_certificate_authorities => [{% for cert in lookup('fileglob', logstash_certs_dir + '/ca/*', wantlist=True) %}"{{ cert }}"{% if not loop.last %}, {% endif %}{% endfor %}]
        ssl_certificate => "{{ logstash_certs_dir }}/{{ logstash_ssl_cert_name }}"
        ssl_key => "{{ logstash_certs_dir }}/{{ logstash_ssl_key_name }}"
        ssl_client_authentication => "required"
        type => "beats"
    }
}

filter {
    if [type] == "beats" {

        # Drop all unknown events
        if [Log_Type] not in ["honfigurator","console","diagnostic","match","proxy"] {
            drop { }
        }


        # # deprecated but still here in case # #
        #
        # remove the hon password for the account in the hon process arguments
        if [system][process][cmdline] =~ /man_masterPassword/ {
            mutate {
            gsub => [
                "[process][command_line]", "((?<=svr_password\s)([^;]*)|(?<=man_masterPassword\s)([^;]*))", "<password>",
                "[system][process][cmdline]", "((?<=svr_password\s)([^;]*)|(?<=man_masterPassword\s)([^;]*))", "<password>",
                "[process][args]", "((?<=svr_password\s)([^;]*)|(?<=man_masterPassword\s)([^;]*))", "<password>"
                ]
            }
        }
        else if [system][process][cmdline] =~ /svr_password/ {
            mutate {
            gsub => [
                "[process][command_line]", "((?<=svr_password\s)([^;]*)|(?<=man_masterPassword\s)([^;]*))", "<password>",
                "[system][process][cmdline]", "((?<=svr_password\s)([^;]*)|(?<=man_masterPassword\s)([^;]*))", "<password>",
                "[process][args]", "((?<=svr_password\s)([^;]*)|(?<=man_masterPassword\s)([^;]*))", "<password>"
                ]
            }
        }
        #
        # # # # # # # # # # #


        # # # # # # # # # # #
        # Filebeat config parsing
        if [@metadata][beat] == "filebeat" {
            #Determine the Server Instance number
            if [Server][Launcher] == "HoNfigurator" {
                if [Log_Type] not in ["match", "diagnostic"] { # match logs dont contain the Slave ID
                    grok {
                        match => ["[log][file][path]",".+?(?=Hon)Hon_Server_%{NUMBER:temp}%{GREEDYDATA}"]
                        match => ["[log][file][path]",".+?(?=Slave)Slave%{NUMBER:temp}%{GREEDYDATA}"]
                        tag_on_failure => ["_honfigurator_match_id_grok_failure"]
                    }
                }
            } else {
                grok {
                    match => ["[log][file][path]",".+?(?=Slave)Slave%{NUMBER:temp}%{GREEDYDATA}"]
                    tag_on_failure => ["_other_launcher_match_id_grok_failure"]
                }
            }
            if [temp] {
                mutate {
                    add_field => { "[Server][Instance]" => "%{[Server][Name]}-%{temp}" }
                }
            } else {
                mutate {
                    add_field => { "[Server][Instance]" => "%{[Server][Name]}"}
                }
            }

            # # # # # # # # # # #
            # Log type specific parsing
            if [Log_Type] in ["console", "match", "diagnostic"] {
                grok {
                    match => [
                        "[log][file][path]",".+?(?=M%{NUMBER})M(?<[Match][ID]>.+?(?=_console))",
                        "[log][file][path]",".+?(?=M%{NUMBER})M(?<[Match][ID]>.+?(?=.log))"
                    ]
                    tag_on_failure => ["_match_match_id_grok_failure"]
                }
            }

            if [Log_Type] == "honfigurator" {
                grok {
                    match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} - %{DATA:[HoNfigurator][Log_Level]} - %{DATA:[HoNfigurator][Filename]}:%{INT:[HoNfigurator][Line_Number]} - %{GREEDYDATA:[@metadata][message]}" }
                    tag_on_failure => ["_honfigurator_log_grok_failure"]
                }
                if [Server][GitHub_Branch] {
                    mutate { add_field => { "[HoNfigurator][GitHub_Branch]" => "%{[Server][GitHub_Branch]}" } }
                }
            } else if [Log_Type] == "match" {
                # Extracting basic event details
                grok {
                    match => [
                        "message","^%{WORD:[Match][Event][Type]} time:%{NUMBER:[Match][Event][Time]} player:%{NUMBER:[Match][Player][ID]}%{GREEDYDATA}$",
                        "message","^%{WORD:[Match][Event][Type]}%{GREEDYDATA}player:%{NUMBER:[Match][Player][ID]}%{GREEDYDATA}$",
                        "message","^%{WORD:[Match][Event][Type]}%{GREEDYDATA}$"
                    ]
                    tag_on_failure => ["_match_generic_grok_failure"]
                }

                # Additional extraction and logic depending on the specific event type
                if [Match][Event][Type] == "EXP_EARNED" {
                    grok {
                        match => { "message" => "^%{GREEDYDATA}experience:%{NUMBER:[Match][Stats][EXP][Earned]}%{GREEDYDATA}$" }
                        tag_on_failure => ["_match_exp_earned_grok_failure"]
                    }
                } else if [Match][Event][Type] == "GOLD_EARNED" {
                    grok {
                        match => { "message" => "^%{GREEDYDATA}gold:%{NUMBER:[Match][Stats][Gold][Earned]}%{GREEDYDATA}$" }
                        tag_on_failure => ["_match_gold_earned_grok_failure"]
                    }
                } else if [Match][Event][Type] == "DAMAGE" { # Handling damage numbers and inflictors
                    grok {
                        patterns_dir => ["/etc/logstash/patterns"]
                        match => [ "message","^%{GREEDYDATA}inflictor:\"%{DATA:[Match][Stats][Damage][Type]}_%{DATA}_%{DATA:[Match][Stats][Damage][Source][Name]}\" target:\"%{DATA:[Match][Stats][Damage][Target][Type]}_%{DATA:[Match][Stats][Damage][Target][Name]}\" damage:%{NUMBER:[Match][Stats][Damage][Dealt]}%{GREEDYDATA}$"]
                        match => [ "message","^%{GREEDYDATA}inflictor:\"%{DATA:[Match][Stats][Damage][Type]}_%{LETTERS}%{NUMBER:[Match][Stats][Damage][Source][Ability]}\" target:\"%{DATA:[Match][Stats][Damage][Target][Type]}_%{DATA:[Match][Stats][Damage][Target][Name]}\" damage:%{NUMBER:[Match][Stats][Damage][Dealt]}%{GREEDYDATA}$"]
                        match => [ "message","^%{GREEDYDATA}inflictor:\"%{DATA:[Match][Stats][Damage][Type]}_%{DATA:[Match][Stats][Damage][Source][Item]}\" target:\"%{DATA:[Match][Stats][Damage][Target][Type]}_%{DATA:[Match][Stats][Damage][Target][Name]}\" damage:%{NUMBER:[Match][Stats][Damage][Dealt]}%{GREEDYDATA}$"]
                        tag_on_failure => ["_match_damage_grok_failure"]
                    }
                    if [Match][Stats][Damage][Type] == "Hero" {
                        mutate { replace => { "[Match][Stats][Damage][Type]" => "Melee" }}
                        if ![Match][Stats][Damage][Source][Type] {
                            mutate { add_field => { "[Match][Stats][Damage][Source][Type]" => "Attack" }}
                        }
                    } else if [Match][Stats][Damage][Type] == "Projectile" and ![Match][Stats][Damage][Source][Type] {
                        mutate { add_field => { "[Match][Stats][Damage][Source][Type]" => "Attack" } }
                    } else if [Match][Stats][Damage][Type] == "Item" and ![Match][Stats][Damage][Source][Type] {
                        mutate { add_field => { "[Match][Stats][Damage][Source][Type]" => "%{[Match][Stats][Damage][Source][Item]}" } }
                    } else if [Match][Stats][Damage][Type] == "Ability" and ![Match][Stats][Damage][Source][Type] {
                        mutate { add_field => { "[Match][Stats][Damage][Source][Type]" => "Ability%{[Match][Stats][Damage][Source][Ability]}" } }
                    }
                } else if [Match][Event][Type] == "INFO_SETTINGS" { # Handling 'INFO_SETTINGS' events to extract and aggregate match mode
                    grok {
                        match => { "message" => "^%{GREEDYDATA}mode:\"%{WORD:[Match][Mode]}\"%{GREEDYDATA}options:\"%{WORD:[Match][Options]}\"$" }
                        tag_on_failure => ["_match_info_settings_grok_failure"]
                    }
                    # Error Handling: Tagging event if extracted field is null
                    if ![Match][Mode] {
                        mutate {
                            add_tag => ["_info_settings_extraction_failure"]
                        }
                    }
                } else if [Match][Event][Type] == "INFO_MAP" {
                    grok {
                        match => { "message" => "^%{GREEDYDATA}name:\"%{WORD:[Match][Map]}\"%{GREEDYDATA}$" }
                        tag_on_failure => ["_match_info_map_grok_failure"]
                    }
                } else if [Match][Event][Type] == "INFO_MATCH" {
                    grok {
                        match => { "message" => "^%{GREEDYDATA}name:\"%{WORD:[Match][Name]}\"%{GREEDYDATA}$" }
                        tag_on_failure => ["_match_info_match_grok_failure"]
                    }
                } else if [Match][Event][Type] == "PLAYER_CONNECT" {
                    grok {
                        match => [ "message","^%{GREEDYDATA}name:\"\[%{GREEDYDATA:[Match][Player][Clan]}\]%{GREEDYDATA:[Match][Player][Name]}\"%{GREEDYDATA}id:%{NUMBER:[Match][Player][Global_ID]}%{GREEDYDATA}psr:%{NUMBER:[Match][Player][PSR]}$"]
                        match => [ "message","^%{GREEDYDATA}name:\"%{GREEDYDATA:[Match][Player][Name]}\"%{GREEDYDATA}id:%{NUMBER:[Match][Player][Global_ID]}%{GREEDYDATA}psr:%{NUMBER:[Match][Player][PSR]}$"]
                        tag_on_failure => ["_match_player_connect_grok_failure"]
                    }
                } else if [Match][Event][Type] == "PLAYER_TEAM_CHANGE" {
                    grok {
                        match => ["message", "^%{GREEDYDATA}team:%{NUMBER:[Match][Player][Team]}$"]
                        tag_on_failure => ["_match_player_team_change_grok_failure"]
                    }
                } else if [Match][Event][Type] in ["PLAYER_SELECT","PLAYER_RANDOM"] {
                    grok {
                        match => [ "message","^%{GREEDYDATA}hero:\"%{DATA}_%{DATA:[Match][Player][Hero]}\"$"]
                        tag_on_failure => ["_match_player_select_grok_failure"]
                    }
                } else if [Match][Event][Type] == "PLAYER_SWAP" {
                    grok {
                        match => [ "message","^%{GREEDYDATA}newhero:\"%{DATA}_%{DATA}:[Match][Player][Hero]}\"$"]
                        tag_on_failure => ["_match_player_swap_grok_failure"]
                    }
                } else if [Match][Event][Type] == "KILL" {
                    grok {
                        match => [
                            "message","^%{GREEDYDATA}team:%{NUMBER:[Match][Player][Team]} target:\"%{DATA:[Match][Stats][Kill][Target][Type]}_%{DATA:[Match][Stats][Kill][Target][Name]}\" attacker:\"%{DATA:[Match][Stats][Kill][Source][Type]}_%{DATA:[Match][Stats][Kill][Source][Name]}\" owner:%{DATA:[Match][Stats][Target][ID]}$",
                            "message","^%{GREEDYDATA}team:%{NUMBER:[Match][Player][Team]} target:\"%{DATA:[Match][Stats][Kill][Target][Type]}_%{DATA:[Match][Stats][Kill][Target][Name]}\" attacker:\"%{DATA:[Match][Stats][Kill][Source][Type]}_%{DATA:[Match][Stats][Kill][Source][Name]}\"%{GREEDYDATA}$"
                        ]
                        tag_on_failure => ["_match_kill_grok_failure"]
                    }
                } else if [Match][Event][Type] == "HERO_DEATH" {
                    grok {
                        match => [
                            "message","^%{GREEDYDATA}team:%{NUMBER:[Match][Player][Team]} attacker:\"%{DATA:[Match][Stats][Kill][Source][Type]}_%{DATA:[Match][Stats][Kill][Source][Name]}\" owner:%{DATA:[Match][Stats][Kill][Source][ID]}$",
                            "message","^%{GREEDYDATA}team:%{NUMBER:[Match][Player][Team]} attacker:\"%{DATA:[Match][Stats][Kill][Source][Type]}_%{DATA:[Match][Stats][Kill][Source][Name]}\"$"
                        ]
                        tag_on_failure => ["_match_hero_death_grok_failure"]
                    }
                } else if [Match][Event][Type] == "PLAYER_CALL_VOTE" {
                    grok {
                        match => [
                            "message","^%{GREEDYDATA}type:%{DATA:[Match][Vote_Type]}$"
                        ]
                        tag_on_failure => ["_match_player_vote_grok_failure"]
                    }
                } else if [Match][Event][Type] == "PLAYER_CHAT" {
                    grok {
                        match => ["message","^%{GREEDYDATA}target:\"%{WORD:[Match][Chat][Type]}\" msg:\"%{GREEDYDATA:[Match][Chat][Message]}\"%{GREEDYDATA}$"]
                    }
                } else if [Match][Event][Type] in ["GAME_CONCEDE", "GAME_END"] {
                } else {
                    drop { }
                }

                if [Match][ID] {
                    # Combining conditions to reduce the number of Elasticsearch filters
                    if [Match][Event][Type] != "PLAYER_CONNECT" and [Match][Player][ID] {
                        if ![Match][Player][Name] {
                            elasticsearch {
                                hosts => [{% for host in elasticsearch_hosts %}"{{ elastic_virtual_proto }}://{{ host }}:{{ hostvars[host].elasticsearch_http_port | default('9200') }}"{% if not loop.last %}, {% endif %}{% endfor %}]
                                ssl_certificate_authorities => "{{ logstash_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"
                                user => "${ES_USER}"
                                password => "${ES_PWD}"
                                index => "alias-match-info"
                                query => "Match.ID:%{[Match][ID]} AND Match.Player.ID:%{[Match][Player][ID]} AND Match.Event.Type:'PLAYER_CONNECT'"
                                fields => { "player_name" => "[Match][Player][Name]" }
                            }
                        } else {
                            mutate {
                                add_field => { "sanitized_client_name" => "%{[Match][Player][Name]}" }
                            }
                            mutate {
                                gsub => ["[sanitized_client_name]", "-", "\\-"]
                            }
                            elasticsearch {
                                hosts => [{% for host in elasticsearch_hosts %}"{{ elastic_virtual_proto }}://{{ host }}:{{ hostvars[host].elasticsearch_http_port | default('9200') }}"{% if not loop.last %}, {% endif %}{% endfor %}]
                                ssl_certificate_authorities => "{{ logstash_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"
                                user => "${ES_USER}"
                                password => "${ES_PWD}"
                                index => "player-ips"
                                query => "Match.Player.Name:%{[sanitized_client_name]}"
                                fields => { "player_ip" => "[Match][Player][IP]" }
                            }
                        }
                    }

                    # Handling multiple event types in a more streamlined fashion
                    if [Match][Event][Type] not in ["INFO_MAP", "INFO_MATCH", "INFO_SETTINGS", "PLAYER_TEAM_CHANGE"] {
                        mutate {
                            add_field => {
                                "match_query" => "Match.ID:%{[Match][ID]} AND Match.Event.Type:'%{[Match][Event][Type]}'"
                            }
                        }
                        elasticsearch {
                            hosts => [{% for host in elasticsearch_hosts %}"{{ elastic_virtual_proto }}://{{ host }}:{{ hostvars[host].elasticsearch_http_port | default('9200') }}"{% if not loop.last %}, {% endif %}{% endfor %}]
                            ssl_certificate_authorities => "{{ logstash_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"
                            user => "${ES_USER}"
                            password => "${ES_PWD}"
                            index => "alias-match-info"
                            query => "%{match_query}"
                            fields => {
                                "match_map" => "[Match][Map]"
                                "match_name" => "[Match][Name]"
                                "match_mode" => "[Match][Mode]"
                                "match_options" => "[Match][Options]"
                                "player_team" => "[Match][Player][Team]"
                                "player_hero" => "[Match][Player][Hero]"
                            }
                        }
                    }

                    # Index specific tagging
                    if [Match][Event][Type] in ["PLAYER_CONNECT","PLAYER_SELECT","PLAYER_RANDOM","PLAYER_TEAM_CHANGE"] {
                        mutate {
                            add_field => { "doc_id_schema" => "%{[Match][ID]}-%{[Match][Event][Type]}-Player-%{[Match][Player][ID]}" }
                        }
                    } else if [Match][Event][Type] in ["INFO_SETTINGS", "INFO_MAP", "INFO_MATCH"] {
                        mutate {
                            add_field => { "doc_id_schema" => "%{[Match][ID]}-%{[Match][Event][Type]}-%{[Match][Event][Type]}" }
                        }
                    }
                }
                
            } else if [Log_Type] in ["console", "k2 console"] {
                grok {
                    patterns_dir => ["/etc/logstash/patterns"]
                    #match => [
                    #    "message","^\[%{HONTIME:timestamp}\](.+?(?=\[))\[%{TIME}\] Client #%{NUMBER:[Match][Player][ID]} %{GREEDYDATA}$"
                    #]
                    match => [
                        "message","^\[%{HONTIME:timestamp}\](.+?(?=\[))\[%{TIME}\] %{NUMBER} \[%{TIME}\] %{GREEDYDATA:[@metadata][message]}$",
                        "message","^\[%{HONTIME:timestamp}\](.+?(?=\[))\[%{TIME}\] %{GREEDYDATA:[@metadata][message]}$",
                        "message","^\[%{HONTIME:timestamp}\] %{GREEDYDATA:[@metadata][message]}$"
                    ]
                    tag_on_failure => ["_console_generic_grok_failure"]
                }

                # Calculate the duration of matches
                elapsed {
                    start_tag => "match_started"
                    end_tag => "match_ended"
                    unique_id_field => "[Match][ID]"
                    timeout => "5400"
                }
                
                # Default status
                mutate {
                    add_field => { "[Server][Event][Severity]" => "OK" }
                }

                if "skipped" in [message] {
                    grok {
                        match => ["[message]","^%{GREEDYDATA}Server skipped %{NUMBER} \(%{NUMBER:[Server][Event][Skipped_Frame][Time]}%{GREEDYDATA}$"]
                        tag_on_failure => ["_console_skipped_frame_grok_failure"]
                    }
                    mutate {
                        add_field => { 
                            "[Server][Event][Type]" => "Skipped server frame"
                        }
                    }
                } else if [message] == "Stat submission successful" {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Successful stat submission" }
                    }
                } else if "game server status update" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Game server status update" }
                    }
                } else if "Sent heartbeat" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Sent heartbeat to chat server" }
                    }
                } else if "Connection to chat server terminated" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Chat server connection terminated." }
                        replace => { "[Server][Event][Severity]" => "ERROR" }
                    }
                } else if "Connected to chat server." in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Connected to chat server" }
                    }
                } else if "Exceeded MAX_PACKET_SIZE" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "DDOS" }
                        replace => { "[Server][Event][Severity]" => "ERROR" }
                    }
                } else if [@metadata][message] =~ /Client #\d+ is flooding/ {
                    grok {
                        match => ["message","^%{GREEDYDATA}Client #%{NUMBER:[Match][Player][ID]}%{GREEDYDATA}$"]
                    }
                    mutate {
                        add_field => { "[Server][Event][Type]" => "DDOS culprit" }
                        replace => { "[Server][Event][Severity]" => "ERROR" }
                    }
                } else if [@metadata][message] =~ /^>.*/ {
                    grok {
                        match => [ "message","%{GREEDYDATA}>%{GREEDYDATA:[Server][Command]}$"]
                        tag_on_failure => [ "_console_command_match_grok_failure" ]
                    }
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Command" }
                        replace => { "[Server][Event][Severity]" => "WARNING" }
                    }
                } else if "Server port is unreachable" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Game server port unavailable" }
                        replace => { "[Server][Event][Severity]" => "ERROR" }
                    }
                } else if "invalid session cookie" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Invalid session cookie" }
                        replace => { "[Server][Event][Severity]" => "ERROR" }
                    }
                } else if "New session cookie" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Obtained session cookie" }
                    }
                } else if [@metadata][message] =~ /^Name:.*/ {
                    grok {
                        match => [
                            "message","^%{GREEDYDATA}Name: \[%{GREEDYDATA:[Match][Player][Clan]}\]%{GREEDYDATA:[Match][Player][Name]}$",
                            "message","^%{GREEDYDATA}Name: %{GREEDYDATA:[Match][Player][Name]}$"
                        ]
                        tag_on_failure => ["_console_connection_name_grok_failure"]
                    }
                    aggregate {
                        task_id => "%{[Log_Type]}-%{[Match][ID]}"
                        code => "
                            map['connection_from'] = event.get('[Match][Player][Name]');
                            map['connection_from_clan'] = event.get('[Match][Player][Clan]');
                        "
                    }
                } else if [@metadata][message] =~ /^IP:.*/  {
                    grok {
                        match => [ "message","^%{GREEDYDATA}IP: %{GREEDYDATA:[Match][Player][IP]}$" ]
                        tag_on_failure => ["_console_connection_ip_grok_failure"]
                    }
                    mutate {
                      add_field => { "player_ip" => "%{[Match][Player][IP]}" }
                    }
                    aggregate {
                        task_id => "%{[Log_Type]}-%{[Match][ID]}"
                        code => "
                            event.set('[Match][Player][Name]', map['connection_from']);
                            event.set('[Match][Player][Clan]', map['connection_from_clan']);
                        "
                    }
                    mutate { add_field => { "[Server][Event][Type]" => "Player connection"}}
                } else if [@metadata][message] =~ /Client #\d+ timing out/ {
                    grok {
                        match => ["message","^%{GREEDYDATA}Client #%{NUMBER:[Match][Player][ID]}%{GREEDYDATA}$"]
                    }
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Player timeout" }
                        replace => { "[Server][Event][Severity]" => "WARNING" }
                    }
                } else if [@metadata][message] =~ /Client #\d+ disconnected: disconnect_timed_out/ {
                    grok {
                        match => ["message","^%{GREEDYDATA}Client #%{NUMBER:[Match][Player][ID]}%{GREEDYDATA}$"]
                    }
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Player disconnected, timeout" }
                        replace => { "[Server][Event][Severity]" => "WARNING" }
                    }
                } else if [@metadata][message] =~ /Client.*disconnected:/ {
                    mutate { add_field => { "[Server][Event][Type]" => "Player disconnection"}}
                } else if [@metadata][message] =~ /Client Reconnected/ {
                    mutate { add_field => { "[Server][Event][Type]" => "Player reconnected"}}
                } else if [message] == "StartMatch" or [Match][Event][Type] == "GAME_START" {
                    mutate {
                        add_tag => "match_started"
                    }
                } else if "EndGame" in [message] or [Match][Event][Type] == "GAME_END" {
                    mutate {
                        add_tag => "match_ended"
                    }
                }
                if [Match][Player][ID] and ![Match][Player][Name] {
                    elasticsearch {
                        hosts => [{% for host in elasticsearch_hosts %}"{{ elastic_virtual_proto }}://{{ host }}:{{ hostvars[host].elasticsearch_http_port | default('9200') }}"{% if not loop.last %}, {% endif %}{% endfor %}]
                        ssl_certificate_authorities => "{{ logstash_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"
                        user => "${ES_USER}"
                        password => "${ES_PWD}"
                        index => "alias-match-info"
                        query => "Match.ID:%{[Match][ID]} AND Match.Player.ID:%{[Match][Player][ID]} AND Match.Player.Name:*"
                        fields => { 
                            "player_name" => "[Match][Player][Name]"
                        }
                    }
                }
            } else if [Log_Type] == "diagnostic" {
                grok {
                    patterns_dir => ["/etc/logstash/patterns"]
                    match => [
                        "message", "%{TIMESTAMP:timestamp} %{WORD:[Diagnostics][entity_tag]} \[%{GREEDYDATA:[Match][Player][Clan]}\]%{DATA:[Diagnostics][client_name]} ip: %{IP:[Diagnostics][client_ip]} ping: %{NUMBER:[Diagnostics][ping]} reliable_sv_sent: %{NUMBER:[Diagnostics][reliable_sv_sent]} reliable_cl_ack: %{NUMBER:[Diagnostics][reliable_cl_ack]} reliable_cl_sent: %{NUMBER:[Diagnostics][reliable_cl_sent]} reliable_sv_ack: %{NUMBER:[Diagnostics][reliable_sv_ack]} unreliable_sv_sent: %{NUMBER:[Diagnostics][unreliable_sv_sent]} unreliable_cl_recv: %{NUMBER:[Diagnostics][unreliable_cl_recv]} unreliable_cl_sent: %{NUMBER:[Diagnostics][unreliable_cl_sent]} unreliable_sv_recv: %{NUMBER:[Diagnostics][unreliable_sv_recv]}",
                        "message", "%{TIMESTAMP:timestamp} %{WORD:[Diagnostics][entity_tag]} %{DATA:[Diagnostics][client_name]} ip: %{IP:[Diagnostics][client_ip]} ping: %{NUMBER:[Diagnostics][ping]} reliable_sv_sent: %{NUMBER:[Diagnostics][reliable_sv_sent]} reliable_cl_ack: %{NUMBER:[Diagnostics][reliable_cl_ack]} reliable_cl_sent: %{NUMBER:[Diagnostics][reliable_cl_sent]} reliable_sv_ack: %{NUMBER:[Diagnostics][reliable_sv_ack]} unreliable_sv_sent: %{NUMBER:[Diagnostics][unreliable_sv_sent]} unreliable_cl_recv: %{NUMBER:[Diagnostics][unreliable_cl_recv]} unreliable_cl_sent: %{NUMBER:[Diagnostics][unreliable_cl_sent]} unreliable_sv_recv: %{NUMBER:[Diagnostics][unreliable_sv_recv]}",
                        "message", "%{TIMESTAMP:timestamp} %{WORD:[Diagnostics][entity_tag]} clients_connected: %{NUMBER:[Diagnostics][clients_connected]} average_ping: %{NUMBER:[Diagnostics][average_ping]} load_average: %{BASE10NUM:[Diagnostics][load_average]} total_long_server_frames: %{NUMBER:[Diagnostics][total_long_server_frames]}"
                    ]
                    tag_on_failure => ["_diagnostic_grok_failure"]
                }
                if [Diagnostics][client_name] {
                    mutate {
                        copy => {
                            "[Diagnostics][client_name]" => "[Match][Player][Name]"
                            # "[Diagnostics][client_ip]" => "[Match][Player][IP]"
                        }
                    }
                    mutate {
                        add_field => {
                            "sanitized_client_name" => "%{[Diagnostics][client_name]}"
                        }
                    }
                    mutate {
                        gsub => [
                            "[sanitized_client_name]", "-", "\\-"
                        ]
                    }
                    elasticsearch {
                        hosts => [{% for host in elasticsearch_hosts %}"{{ elastic_virtual_proto }}://{{ host }}:{{ hostvars[host].elasticsearch_http_port | default('9200') }}"{% if not loop.last %}, {% endif %}{% endfor %}]
                        ssl_certificate_authorities => "{{ logstash_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"
                        user => "${ES_USER}"
                        password => "${ES_PWD}"
                        index => "player-ips"
                        query => "Match.Player.Name:%{[sanitized_client_name]}"
                        fields => { 
                            "player_ip" => "[Match][Player][IP]"
                        }
                    }
                }
            }
            
            # Retrieving mapped values
            # aggregate {
            #     task_id => "%{[Match][ID]}"
            #     # Safeguarding field retrieval with conditional checks to avoid null pointer issues
            #     code => "
            #         player_id = event.get('[Match][Player][ID]')
            #         player_info = map['player'][player_id] if map['player']

            #         event.set('[Match][Player][Name]', player_info['name']) if player_info && player_info['name']
            #         event.set('[Match][Player][Clan]', player_info['clan']) if player_info && player_info['clan']
            #         event.set('[Match][Player][Team]', player_info['team']) if player_info && player_info['team']
            #         event.set('[Match][Player][Hero]', player_info['hero']) if player_info && player_info['hero']
            #         event.set('[Match][Mode]', map['match_mode']) if map['match_mode']
            #         event.set('[Match][Options]', map['match_options']) if map['match_options']
            #         event.set('[Match][Map]', map['match_map']) if map['match_map']
            #     "
            # }
            mutate {
                gsub => [
                    "[Match][Mode]", "Mode_", "",
                    "[Match][Options]", "Option_", ""
                ]
            }
            mutate {
                copy => {
                    "[Match][Player][ID]" => "player_id"
                    "[Match][Player][Name]" => "player_name"
                    "[Match][Player][Hero]" => "player_hero"
                    "[Match][Player][Team]" => "player_team"
                    "[Match][Name]" => "match_name"
                    "[Match][Map]" => "match_map"
                    "[Match][Mode]" => "match_mode"
                    "[Match][Options]" => "match_options"
                }
                lowercase => [
                    "[Match][Mode]",
                    "[Match][Options]",
                    "[Match][Map]",
                    "match_mode",
                    "match_options",
                    "match_map"
                ]
            }

            # Translate team IDs to human-readable names
            translate {
                source => "[Match][Player][Team]"
                target => "[Match][Player][Team]"
                dictionary => {
                    "0" => "No_team"
                    "1" => "Legion"
                    "2" => "Hellbourne"
                }
                fallback => "No_team"
                override => true
            }
        }

        # Handle date parsing with timezone consideration
        if [event][timezone] {
            date {
                match => ["timestamp", "MMM dd HH:mm:ss","MMM d HH:mm:ss","yyyy-MM-dd HH:mm:ss,SSS","yyyy/dd/MM HH:mm:ss"]
                target => "@timestamp"
                timezone => "%{[event][timezone]}"
            }
        } else {
            date {
                match => ["timestamp", "MMM dd HH:mm:ss","MMM d HH:mm:ss","yyyy-MM-dd HH:mm:ss,SSS","yyyy/dd/MM HH:mm:ss"]
                target => "@timestamp"
            }
        }

        # Perform multiple mutate operations in a single block
        if [Server][Name] {
            mutate {
                copy => {
                    "[Server][Name]" => "[server][name][lc]"
                }
            }
        } else if [Server][0][Name] {
            mutate {
                copy => {
                    "[Server][0][Name]" => "[server][name][lc]"
                }
            }
        }
        mutate {
            rename => {"[@metadata][message]" => "[message]"}
            lowercase => ["[server][name][lc]"]
            uppercase => ["[Match][Chat][Type]"]
        }
        mutate {
            gsub => [
                "[server][name][lc]", "[\"\ .]", "-",
                "[Server][Admin]","#","-"
            ]
        }
    }
}

output {
    if [type] == "beats" and [@metadata][beat] == "filebeat" {
        elasticsearch {
            pipeline => "geoip-info"
            index => "%{[@metadata][beat]}-%{[server][name][lc]}-%{[Log_Type]}"
            hosts => [{% for host in elasticsearch_hosts %}"{{ elastic_virtual_proto }}://{{ host }}:{{ hostvars[host].elasticsearch_http_port | default('9200') }}"{% if not loop.last %}, {% endif %}{% endfor %}]
            ssl_certificate_authorities => "{{ logstash_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"
            user => "${ES_USER}"
            password => "${ES_PWD}"
            action => "create"
        }

        if [Match][Player][Name] and [Match][Player][IP] and [Server][Event][Type] == "Player connection" and [Log_Type] == "console" {
            elasticsearch {
                hosts => [{% for host in elasticsearch_hosts %}"{{ elastic_virtual_proto }}://{{ host }}:{{ hostvars[host].elasticsearch_http_port | default('9200') }}"{% if not loop.last %}, {% endif %}{% endfor %}]
                ssl_certificate_authorities => "{{ logstash_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"
                user => "${ES_USER}"
                password => "${ES_PWD}"
                index => "player-ips"
                document_id => "%{[Match][Player][Name]}"  # Prevent duplicates by using player name as document ID
                pipeline => "geoip-info"
            }
        }

        if [Log_Type] == "match" and [doc_id_schema] {
            elasticsearch {
                hosts => [{% for host in elasticsearch_hosts %}"{{ elastic_virtual_proto }}://{{ host }}:{{ hostvars[host].elasticsearch_http_port | default('9200') }}"{% if not loop.last %}, {% endif %}{% endfor %}]
                ssl_certificate_authorities => "{{ logstash_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"
                user => "${ES_USER}"
                password => "${ES_PWD}"
                index => "alias-match-info"
                pipeline => "geoip-info"
                document_id => "%{doc_id_schema}"
                doc_as_upsert => true
            }
        }
    }
}
