
input {
    beats {
        port => 5044
        ssl_enabled => true
        ssl_certificate_authorities => [{% for cert in lookup('fileglob', logstash_certs_dir + '/ca/*', wantlist=True) %}"{{ cert }}"{% if not loop.last %}, {% endif %}{% endfor %}]
        ssl_certificate => "{{ logstash_certs_dir }}/cert1.pem"
        ssl_key => "{{ logstash_certs_dir }}/privkey1.pem"
        ssl_client_authentication => "required"
        type => "beats"
    }
}

filter {
    if [type] == "beats" {
        # # deprecated but still here in case # #
        #
        # remove the hon password for the account in the hon process arguments
        if  [system][process][cmdline] =~ /man_masterPassword/ {
            mutate {
            gsub => [
                "[process][command_line]", "((?<=svr_password\s)([^;]*)|(?<=man_masterPassword\s)([^;]*))", "<password>",
                "[system][process][cmdline]", "((?<=svr_password\s)([^;]*)|(?<=man_masterPassword\s)([^;]*))", "<password>",
                "[process][args]", "((?<=svr_password\s)([^;]*)|(?<=man_masterPassword\s)([^;]*))", "<password>"
                ]
            }
        }
        else if [system][process][cmdline] =~ /svr_password/ {
            mutate {
            gsub => [
                "[process][command_line]", "((?<=svr_password\s)([^;]*)|(?<=man_masterPassword\s)([^;]*))", "<password>",
                "[system][process][cmdline]", "((?<=svr_password\s)([^;]*)|(?<=man_masterPassword\s)([^;]*))", "<password>",
                "[process][args]", "((?<=svr_password\s)([^;]*)|(?<=man_masterPassword\s)([^;]*))", "<password>"
                ]
            }
        }
        #
        # # # # # # # # # # #


        # # # # # # # # # # #
        # Filebeat config parsing
        if [@metadata][beat] == "filebeat" {
            #Determine the Server Instance number
            if [Server][Launcher] == "HoNfigurator" {
                if [Log_Type] not in ["match", "diagnostic"] { # match logs dont contain the Slave ID
                    grok {
                        match => ["[log][file][path]",".+?(?=Hon)Hon_Server_%{NUMBER:temp}%{GREEDYDATA}"]
                        match => ["[log][file][path]",".+?(?=Slave)Slave%{NUMBER:temp}%{GREEDYDATA}"]
                        tag_on_failure => ["_honfigurator_match_id_grok_failure"]
                    }
                }
            } else {
                grok {
                    match => ["[log][file][path]",".+?(?=Slave)Slave%{NUMBER:temp}%{GREEDYDATA}"]
                    tag_on_failure => ["_other_launcher_match_id_grok_failure"]
                }
            }
            if [temp] {
                mutate {
                    add_field => { "[Server][Instance]" => "%{[Server][Name]}-%{temp}" }
                }
            } else {
                mutate {
                    add_field => { "[Server][Instance]" => "%{[Server][Name]}"}
                }
            }

            # # # # # # # # # # #
            # Log type specific parsing
            if [Log_Type] in ["console", "match", "diagnostic"] {
                grok {
                    match => [
                        "[log][file][path]",".+?(?=M%{NUMBER})M(?<[Match][ID]>.+?(?=_console))",
                        "[log][file][path]",".+?(?=M%{NUMBER})M(?<[Match][ID]>.+?(?=.log))"
                    ]
                    tag_on_failure => ["_match_match_id_grok_failure"]
                }
            }

            if [Log_Type] == "honfigurator" {
                grok {
                    match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} - %{DATA:[HoNfigurator][Log_Level]} - %{DATA:[HoNfigurator][Filename]}:%{INT:[HoNfigurator][Line_Number]} - %{GREEDYDATA:[@metadata][message]}" }
                    tag_on_failure => ["_honfigurator_log_grok_failure"]
                }
            } else if [Log_Type] == "diagnostic" {
                grok {
                    patterns_dir => ["/etc/logstash/patterns"]
                    match => [
                        "message", "%{TIMESTAMP:timestamp} %{WORD:[Diagnostics][entity_tag]} %{DATA:[Diagnostics][client_name]} ip: %{IP:[Diagnostics][client_ip]} ping: %{NUMBER:[Diagnostics][ping]} reliable_sv_sent: %{NUMBER:[Diagnostics][reliable_sv_sent]} reliable_cl_ack: %{NUMBER:[Diagnostics][reliable_cl_ack]} reliable_cl_sent: %{NUMBER:[Diagnostics][reliable_cl_sent]} reliable_sv_ack: %{NUMBER:[Diagnostics][reliable_sv_ack]} unreliable_sv_sent: %{NUMBER:[Diagnostics][unreliable_sv_sent]} unreliable_cl_recv: %{NUMBER:[Diagnostics][unreliable_cl_recv]} unreliable_cl_sent: %{NUMBER:[Diagnostics][unreliable_cl_sent]} unreliable_sv_recv: %{NUMBER:[Diagnostics][unreliable_sv_recv]}",
                        "message", "%{TIMESTAMP:timestamp} %{WORD:[Diagnostics][entity_tag]} clients_connected: %{NUMBER:[Diagnostics][clients_connected]} average_ping: %{NUMBER:[Diagnostics][average_ping]} load_average: %{BASE10NUM:[Diagnostics][load_average]} total_long_server_frames: %{NUMBER:[Diagnostics][total_long_server_frames]}"
                    ]
                    tag_on_failure => ["_diagnostic_grok_failure"]
                }
                mutate {
                    copy => {
                        "[Diagnostics][client_name]" => "[Match][Player][Name]"
                        "[Diagnostics][client_ip]" => "[Match][Player][IP]"
                    }
                }
            } else if [Log_Type] in ["console", "k2 console"] {
                ## THIS ENTIRE SECTION TO BE DEPRECATED ##
                grok {
                    patterns_dir => ["/etc/logstash/patterns"]
                    match => [
                        "message","^\[%{HONTIME:timestamp}\](.+?(?=\[))\[%{TIME}\] %{NUMBER} \[%{TIME}\] %{GREEDYDATA:[@metadata][message]}$",
                        "message","^\[%{HONTIME:timestamp}\](.+?(?=\[))\[%{TIME}\] Client #%{NUMBER:[Match][Player][ID]} %{GREEDYDATA:[@metadata][message]}$",
                        "message","^\[%{HONTIME:timestamp}\](.+?(?=\[))\[%{TIME}\] %{GREEDYDATA:[@metadata][message]}$",
                        "message","^\[%{HONTIME:timestamp}\] Client #%{NUMBER:[Match][Player][ID]} %{GREEDYDATA:[@metadata][message]}$",
                        "message","^\[%{HONTIME:timestamp}\] %{GREEDYDATA:[@metadata][message]}$"
                    ]
                    tag_on_failure => ["_console_generic_grok_failure"]
                }

                # Calculate the duration of matches
                elapsed {
                    start_tag => "match_started"
                    end_tag => "match_ended"
                    unique_id_field => "[Match][ID]"
                    timeout => "4000"
                }
                
                # Default status
                mutate {
                    add_field => { "[Server][Event][Severity]" => "OK" }
                }

                if "skipped" in [message] {
                    grok {
                        match => ["[message]","^%{GREEDYDATA}Server skipped %{NUMBER} \(%{NUMBER:[Server][Event][Skipped_Frame][Time]}%{GREEDYDATA}$"]
                        tag_on_failure => ["_console_skipped_frame_grok_failure"]
                    }
                    mutate {
                        add_field => { 
                            "[Server][Event][Type]" => "Skipped server frame"
                        }
                    }
                } else if [message] == "Stat submission successful" {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Successful stat submission" }
                    }
                } else if "game server status update" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Game server status update" }
                    }
                } else if "Sent heartbeat" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Sent heartbeat to chat server" }
                    }
                } else if "Connection to chat server terminated" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Chat server connection terminated." }
                        add_field => { "[Server][Event][Severity]" => "ERROR" }
                    }
                } else if "Connected to chat server." in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Connected to chat server" }
                        add_field => { "[Server][Event][Severity]" => "OK" }
                    }
                } else if "Exceeded MAX_PACKET_SIZE" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "DDOS" }
                        add_field => { "[Server][Event][Severity]" => "ERROR" }
                    }
                } else if [message] =~ /Client #\d+ is flooding/ {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "DDOS culprit" }
                        add_field => { "[Server][Event][Severity]" => "ERROR" }
                    }
                } else if "Server port is unreachable" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Game server port unavailable" }
                        add_field => { "[Server][Event][Severity]" => "ERROR" }
                    }
                } else if "invalid session cookie" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Invalid session cookie" }
                        add_field => { "[Server][Event][Severity]" => "ERROR" }
                    }
                } else if "New session cookie" in [message] {
                    mutate {
                        add_field => { "[Server][Event][Type]" => "Obtained session cookie" }
                    }
                } else if [message] =~ /^Name:.*/ {
                    grok {
                        match => [ "message","^Name: %{GREEDYDATA:[Match][Player][Name]}"]
                        tag_on_failure => ["_console_connection_name_grok_failure"]
                    }
                    mutate { add_field => { "[Server][Event][Type]" => "Player connection"}}
                } else if [message] =~ /^IP:.*/  {
                    grok {
                        match => [ "message","^IP: %{GREEDYDATA:[Server][Event][Connection][IP]}" ]
                        tag_on_failure => ["_console_connection_ip_grok_failure"]
                    }
                } else if [message] =~ /Client.*disconnected:/ {
                    mutate { add_field => { "[Server][Event][Type]" => "Player disconnection"}}
                } else if [message] =~ /Client Reconnected/ {
                    mutate { add_field => { "[Server][Event][Type]" => "Player reconnected"}}
                } else if [message] == "StartMatch" or [Match][Event][Type] == "GAME_START" {
                    mutate {
                        add_tag => "match_started"
                    }
                } else if "EndGame" in [message] or [Match][Event][Type] == "GAME_END" {
                    mutate {
                        add_tag => "match_ended"
                    }
                }
            } else if [Log_Type] == "match" {
                # Extracting basic event details
                grok {
                    match => [ "message","^%{WORD:[Match][Event][Type]} time:%{NUMBER} player:%{NUMBER:[Match][Player][ID]} target:\"%{WORD:[Match][Chat][Type]}\" msg:\"%{GREEDYDATA:[Match][Chat][Message]}\"%{GREEDYDATA}$"]
                    match => [ "message","^%{WORD:[Match][Event][Type]} player:%{NUMBER:[Match][Player][ID]} target:\"%{WORD:[Match][Chat][Type]}\" msg:\"%{GREEDYDATA:[Match][Chat][Message]}\"%{GREEDYDATA}$"]
                    match => [ "message","^%{WORD:[Match][Event][Type]} %{GREEDYDATA}time:%{NUMBER:[Match][Event][Time]} %{GREEDYDATA}player:%{NUMBER:[Match][Player][ID]} %{GREEDYDATA}team:%{NUMBER:[Match][Player][Team]}%{GREEDYDATA}$"]
                    match => [ "message","^%{WORD:[Match][Event][Type]} %{GREEDYDATA}player:%{NUMBER:[Match][Player][ID]} %{GREEDYDATA}team:%{NUMBER:[Match][Player][Team]}%{GREEDYDATA}$"]
                    match => [ "message","^%{WORD:[Match][Event][Type]} %{GREEDYDATA}player:%{NUMBER:[Match][Player][ID]}%{GREEDYDATA}$"]
                    match => [ "message","^%{WORD:[Match][Event][Type]}%{GREEDYDATA}$"]
                    tag_on_failure => ["_match_generic_grok_failure"]
                }

                # Additional extraction and logic depending on the specific event type
                if [Match][Event][Type] == "KILL" {
                    grok {
                        match => { "message" => "^%{GREEDYDATA}team:%{NUMBER:[Match][Player][Team]}%{GREEDYDATA}target:\"%{DATA:[Match][Stats][Kill][Target_Type]}_%{DATA:[Match][Stats][Kill][Target]}\" attacker:\"%{DATA:[Match][Stats][Kill][Source_Type]}_%{DATA:[Match][Stats][Kill][Source]}\"%{GREEDYDATA}$" }
                        tag_on_failure => ["_match_kill_grok_failure"]
                    }
                } else if [Match][Event][Type] == "EXP_EARNED" {
                    grok {
                        match => { "message" => "^%{GREEDYDATA}experience:%{NUMBER:[Match][Stats][Exp_Earned]}%{GREEDYDATA}$" }
                        tag_on_failure => ["_match_exp_earned_grok_failure"]
                    }
                } else if [Match][Event][Type] == "GOLD_EARNED" {
                    grok {
                        match => { "message" => "^%{GREEDYDATA}gold:%{NUMBER:[Match][Stats][Gold_Earned]}%{GREEDYDATA}$" }
                        tag_on_failure => ["_match_gold_earned_grok_failure"]
                    }
                } else if [Match][Event][Type] == "DAMAGE" { # Handling damage numbers and inflictors
                    grok {
                        patterns_dir => ["/etc/logstash/patterns"]
                        match => [ "message","^%{GREEDYDATA}inflictor:\"%{DATA:[Match][Stats][Damage][Type]}_%{DATA}_%{DATA:[Match][Stats][Damage][Source]}\" target:\"%{DATA:[Match][Stats][Damage][Target_Type]}_%{DATA:[Match][Stats][Damage][Target]}\" damage:%{NUMBER:[Match][Stats][Damage][Dealt]}%{GREEDYDATA}$"]
                        match => [ "message","^%{GREEDYDATA}inflictor:\"%{DATA:[Match][Stats][Damage][Type]}_%{LETTERS}%{NUMBER:[Match][Stats][Damage][Ability_Source]}\" target:\"%{DATA:[Match][Stats][Damage][Target_Type]}_%{DATA:[Match][Stats][Damage][Target]}\" damage:%{NUMBER:[Match][Stats][Damage][Dealt]}%{GREEDYDATA}$"]
                        match => [ "message","^%{GREEDYDATA}inflictor:\"%{DATA:[Match][Stats][Damage][Type]}_%{DATA:[Match][Stats][Damage][Item_Source]}\" target:\"%{DATA:[Match][Stats][Damage][Target_Type]}_%{DATA:[Match][Stats][Damage][Target]}\" damage:%{NUMBER:[Match][Stats][Damage][Dealt]}%{GREEDYDATA}$"]
                        tag_on_failure => ["_match_damage_grok_failure"]
                    }
                    if [Match][Stats][Damage][Type] == "Hero" {
                        mutate { replace => { "[Match][Stats][Damage][Type]" => "Melee" }}
                        if ![Match][Stats][Damage][Source] {
                            mutate { add_field => { "[Match][Stats][Damage][Source]" => "Attack" }}
                        }
                    } else if [Match][Stats][Damage][Type] == "Projectile" and ![Match][Stats][Damage][Source] {
                        mutate { add_field => { "[Match][Stats][Damage][Source]" => "Attack" } }
                    } else if [Match][Stats][Damage][Type] == "Item" and ![Match][Stats][Damage][Source] {
                        mutate { add_field => { "[Match][Stats][Damage][Source]" => "%{[Match][Stats][Damage][Item_Source]}" } }
                    } else if [Match][Stats][Damage][Type] == "Ability" and ![Match][Stats][Damage][Source] {
                        mutate { add_field => { "[Match][Stats][Damage][Source]" => "Ability%{[Match][Stats][Damage][Ability_Source]}" } }
                    }
                } else if [Match][Event][Type] == "INFO_SETTINGS" { # Handling 'INFO_SETTINGS' events to extract and aggregate match mode
                    grok {
                        match => { "message" => "^%{GREEDYDATA}mode:\"%{WORD:[Match][Mode]}\"%{GREEDYDATA}options:\"%{WORD:[Match][Options]}\"$" }
                        tag_on_failure => ["_match_info_settings_grok_failure"]
                    }
                    # Error Handling: Tagging event if extracted field is null
                    if ![Match][Mode] {
                        mutate {
                            add_tag => ["_info_settings_extraction_failure"]
                        }
                    }
                    aggregate {
                        task_id => "%{[Match][ID]}"
                        code => "
                            map['match_mode'] = event.get('[Match][Mode]')
                            map['match_options'] = event.get('[Match][Options]')
                        "
                    }
                } else if [Match][Event][Type] == "INFO_MAP" {
                    grok {
                        match => { "message" => "^%{GREEDYDATA}name:\"%{WORD:[Match][Map]}\"%{GREEDYDATA}$" }
                        tag_on_failure => ["_match_info_map_grok_failure"]
                    }
                    # Error Handling: Tagging event if extracted field is null
                    if ![Match][Map] {
                        mutate {
                            add_tag => ["_info_map_extraction_failure"]
                        }
                    }
                    aggregate {
                        task_id => "%{[Match][ID]}"
                        code => "map['match_map'] = event.get('[Match][Map]')"
                    }
                } else if [Match][Event][Type] == "PLAYER_CONNECT" {
                    grok {
                        match => [ "message","^%{GREEDYDATA}name:\"%{GREEDYDATA:[Match][Player][Name]}\"%{GREEDYDATA}id:%{NUMBER:[Match][Player][Global_ID]}%{GREEDYDATA}psr:%{NUMBER:[Match][Player][PSR]}$"]
                        tag_on_failure => ["_match_player_connect_grok_failure"]
                    }
                    aggregate {
                        task_id => "%{[Match][ID]}"
                        code => "
                            map['player'] ||= {}
                            map['player'][event.get('[Match][Player][ID]')] = {'name' => event.get('[Match][Player][Name]'), 'team' => event.get('[Match][Player][Team]')}
                        "
                    }
                } else if [Match][Event][Type] == "PLAYER_CHAT" {
                } else if [Match][Event][Type] == "PLAYER_TEAM_CHANGE" {
                    aggregate {
                        task_id => "%{[Match][ID]}"
                        code => "
                            map['player'] ||= {}
                            player_id = event.get('[Match][Player][ID]')
                            map['player'][player_id] ||= {}
                            
                            map['player'][player_id]['team'] = event.get('[Match][Player][Team]') if event.get('[Match][Player][Team]')
                        "
                    }
                } else if [Match][Event][Type] == "PLAYER_SELECT" {
                    grok {
                        match => [ "message","^%{GREEDYDATA}hero:\"%{DATA}_%{DATA:[Match][Player][Hero]}\"$"]
                        tag_on_failure => ["_match_player_select_grok_failure"]
                    }
                    aggregate {
                        task_id => "%{[Match][ID]}"
                        code => "
                            map['player'] ||= {}
                            map['player'][event.get('[Match][Player][ID]')] ||= {}
                            map['player'][event.get('[Match][Player][ID]')]['hero'] = event.get('[Match][Player][Hero]')
                        "
                    }
                } else if [Match][Event][Type] == "PLAYER_SWAP" {
                    grok {
                        match => [ "message","^%{GREEDYDATA}newhero:\"%{DATA}_%{DATA}:[Match][Player][Hero]}\"$"]
                        tag_on_failure => ["_match_player_swap_grok_failure"]
                    }
                    aggregate {
                        task_id => "%{[Match][ID]}"
                        code => "
                            map['player'] ||= {}
                            map['player'][event.get('[Match][Player][ID]')] ||= {}
                            map['player'][event.get('[Match][Player][ID]')]['hero'] = event.get('[Match][Player][Hero]')
                        "
                    }
                } else {
                    drop { }
                }

                if [Match][Player][ID] {
                    mutate {
                        add_field => { "[Match][Player][ID-Match]" => "%{[Match][Player][ID]}-%{[Match][ID]}" }
                    }
                }

                # Retrieving mapped values
                aggregate {
                    task_id => "%{[Match][ID]}"
                    # Safeguarding field retrieval with conditional checks to avoid null pointer issues
                    code => "
                        player_id = event.get('[Match][Player][ID]')
                        player_info = map['player'][player_id] if map['player']

                        event.set('[Match][Player][Name]', player_info['name']) if player_info && player_info['name']
                        event.set('[Match][Player][Team]', player_info['team']) if player_info && player_info['team']
                        event.set('[Match][Player][Hero]', player_info['hero']) if player_info && player_info['hero']
                        event.set('[Match][Mode]', map['match_mode']) if map['match_mode']
                        event.set('[Match][Options]', map['match_options']) if map['match_options']
                        event.set('[Match][Map]', map['match_map']) if map['match_map']
                    "
                }
                # Translate team IDs to human-readable names
                translate {
                    source => "[Match][Player][Team]"
                    target => "[Match][Player][Team]"
                    dictionary => {
                        "0" => "No_team"
                        "1" => "Legion"
                        "2" => "Hellbourne"
                    }
                    fallback => "No_team"
                    override => true
                }
            }
        }

        # Handle date parsing with timezone consideration
        if [event][timezone] {
            date {
                match => ["timestamp", "MMM dd HH:mm:ss","MMM d HH:mm:ss","yyyy-MM-dd HH:mm:ss,SSS","yyyy/dd/MM HH:mm:ss"]
                target => "@timestamp"
                timezone => "%{[event][timezone]}"
            }
        } else {
            date {
                match => ["timestamp", "MMM dd HH:mm:ss","MMM d HH:mm:ss","yyyy-MM-dd HH:mm:ss,SSS","yyyy/dd/MM HH:mm:ss"]
                target => "@timestamp"
            }
        }

        # Perform multiple mutate operations in a single block
        mutate {
            add_field => {"[server][name][lc]" => "%{[Server][Name]}"}
        }
        mutate {
            rename => {"[@metadata][message]" => "[message]"}
            lowercase => ["[server][name][lc]"]
            uppercase => ["[Match][Chat][Type]"]
        }
        mutate {
            gsub => [
                "[server][name][lc]", "[\"\ .]", "-",
                "[Server][Admin]","#","-"
            ]
        }
    }
}

output {
    if [type] == "beats" and [@metadata][beat] == "filebeat" {
        elasticsearch {
            hosts => [{% for host in elasticsearch_hosts %}"https://{{ host }}:9200"{% if not loop.last %}, {% endif %}{% endfor %}]
            pipeline => "geoip-info"
            index => "%{[@metadata][beat]}-%{[Log_Type]}"
            ssl_certificate_authorities => "{{ logstash_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"
            user => "${ES_USER}"
            password => "${ES_PWD}"
            action => "create"
        }
    }
}
