import requests
from elasticsearch import Elasticsearch
import urllib3
import phpserialize
import concurrent.futures
import json

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def recursive_php_decode(item):
    # If the item is bytes, decode it
    if isinstance(item, bytes):
        return item.decode('utf-8')
    # If the item is a dictionary, decode its keys and values (recursively)
    elif isinstance(item, dict):
        return {recursive_php_decode(key): recursive_php_decode(value) for key, value in item.items()}
    # If the item is a list, decode its elements (recursively)
    elif isinstance(item, list):
        return [recursive_php_decode(element) for element in item]
    # Return the item as is if none of the above conditions are met
    else:
        return item

def fetch_api_data(api_endpoint):
    try:
        response = requests.get(api_endpoint, verify=False)
        if response.status_code == 200:
            api_data = response.json()
            api_data['api_online'] = True  # API call was successful
            return api_data
        else:
            return {"api_online": False, "error": f"Non-200 status code: {response.status_code}"}
    except requests.exceptions.RequestException as e:
        return {"api_online": False, "error": str(e)}

class KongorAPIClient():
    def __init__(self):
        self.url = "http://api.kongor.online/client_requester.php?f=server_list"
        self.data = {
            "gametype" : "90",
            "cookie" : "123"
        }
        self.server_dict = {}
    
    def get_server_list(self, auto_region=False):
        data = self.data.copy()

        if auto_region:
            data["region"] = "AUTO"
        response = requests.post(self.url, data = data)
        if not response.status_code == 200:
            print(json.dumps({"error":"Failed to access kongor API"}))
            exit(1)
        
        return response

class ServerList():
    def __init__(self):
        pass
    
    def parse_server_list(self, server_list):
        parsed = phpserialize.loads(server_list.text.encode('utf-8'))
        parsed = recursive_php_decode(parsed)

        servers = {}
        server_list = parsed["server_list"]

        for server in server_list.values():
            ip = server["ip"]
            new_name = server["location"].replace(' 0', '') if ' 0' in server["location"] else 'no_name'  # Remove the ' 0' suffix from the name (if present
            # name = server.get("location", "no_name")  # Use a default if name is not available
            # unique_key = (ip, name)  # Creating a tuple of IP and name

            servers[ip] = server
            servers[ip]['name'] = new_name

        return servers

def query_elastic(server_list=None):
    # Your Elasticsearch credentials
    ES_USERNAME = 'elastic'
    ES_PASSWORD = '{{ elasticsearch_users['elastic']['password'] }}'

    # Setup Elasticsearch connection
    es = Elasticsearch(['https://elastic-node2.honfigurator.app:9200'], basic_auth=(ES_USERNAME, ES_PASSWORD))

    # Query the 'last-svr-state' index
    response = es.search(
        index="last-svr-state-highlvl",
        filter_path=["hits.hits._source"],
        query={
            "bool": {
                "must": {
                    "exists": {
                        "field": "svr_api_port"
                    }
                }
            }
        },
        size=1000  # Adjust the number as needed
    )

    # Check for errors in the Elasticsearch response
    if response.get('errors', False):
        print(json.dumps({"error": "Errors found in Elasticsearch response."}))
        exit(1)
    
    elastic_server_list = {}
    for hit in response['hits']['hits']:
        server = hit['_source']
        svr_ip = server['svr_ip']
        #svr_autoping_port = server['autoping_responder_port'] # future release
        svr_name = server.get('svr_name', 'default_name')  # Use a default if name is not available
        svr_name = svr_name.replace(' 0', '')  # Remove the ' 0' suffix from the name (if present
        unique_key = (svr_ip, svr_name)  # Creating a tuple of IP and name

        elastic_server_list[unique_key] = server

    return elastic_server_list


def query_honfig_api_parallel(server_list):
    overall_data = {}
    with concurrent.futures.ThreadPoolExecutor() as executor:
        # Create a dictionary to map futures to IPs
        future_to_ip = {}
        for ip, data in server_list.items():
            if 'svr_api_port' not in data:
                data['svr_api_port'] = 5000 # A GUESS, as this is the default API port
            
            api_endpoint = f"https://{ip}:{data['svr_api_port']}/api/public/check_filebeat_status"
            future = executor.submit(fetch_api_data, api_endpoint)
            future_to_ip[future] = ip

        for future in concurrent.futures.as_completed(future_to_ip):
            ip = future_to_ip[future]
            api_data = future.result()
            
            if 'certificate_valid' in api_data and api_data['certificate_status'].startswith('valid'):
                api_data['certificate_valid'] = True
            else:
                api_data['certificate_valid'] = False
                
            api_data['autoping'] = True
            overall_data[ip] = api_data
            overall_data[ip]['in_elastic'] = server_list[ip]['in_elastic']
            overall_data[ip]['port'] = server_list[ip]['port']
            overall_data[ip]['name'] = server_list[ip]['location'] if ' 0' in server_list[ip]['location'] else ''
    
    return overall_data

def main():
    kongor_api_client = KongorAPIClient()
    server_list = ServerList()

    kongor_server_list_autoping = server_list.parse_server_list(kongor_api_client.get_server_list(auto_region=True))
    kongor_server_list_all = server_list.parse_server_list(kongor_api_client.get_server_list(auto_region=False))

    kongor_server_list_all.update(kongor_server_list_autoping)

    servers_not_running_autoping = {k: v for k, v in kongor_server_list_all.items() if k not in kongor_server_list_autoping}

    server_list_elastic = query_elastic()

    if not kongor_server_list_all:
        return

    # Updated section to handle composite keys
    for key, server_info in kongor_server_list_all.items():
        # Adjust the key to match the composite key format
        elastic_key = (server_info["ip"], server_info.get("name", "no_name"))

        if elastic_key in server_list_elastic:
            server_info['in_elastic'] = True
            server_info['svr_api_port'] = server_list_elastic[elastic_key].get('svr_api_port', 5000)
        else:
            server_info['in_elastic'] = False

    # Proceed with the rest of the function
    status = query_honfig_api_parallel(kongor_server_list_all)

    for server_key in servers_not_running_autoping:
        status[server_key].update({'autoping': False})

    for server_key, data in status.items():
        server_data = {
            "ip": server_key[0],  # Extracting IP from the composite key
            "name": server_key[1], # Extracting name from the composite key
            **data
        }
        print(json.dumps(server_data))

    return status

if __name__ == "__main__":
    main()

    
    
if __name__ == "__main__":
    main()