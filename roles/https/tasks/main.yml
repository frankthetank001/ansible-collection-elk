---
- set_fact:
    virtual_proto: "{{ 'https' if elasticsearch_https_enabled else 'http' }}"

- name: Install certbot (Debian-based systems)
  ansible.builtin.apt:
    name: certbot
    state: present
  when: ansible_os_family == 'Debian'

- name: Install python3-certbot-dns-cloudflare (Debian-based systems)
  ansible.builtin.apt:
    name: python3-certbot-dns-cloudflare
    state: present
  when: ansible_os_family == 'Debian'

- name: Install certbot (RedHat-based systems)
  ansible.builtin.yum:
    name: certbot
    state: present
  when: ansible_os_family == 'RedHat'

- name: Install python3-certbot-dns-cloudflare (RedHat-based systems)
  ansible.builtin.yum:
    name: python3-certbot-dns-cloudflare
    state: present
  when: ansible_os_family == 'RedHat'

- name: Check if certificate exists
  ansible.builtin.stat:
    path: "/etc/letsencrypt/live/{{ inventory_hostname|lower }}/fullchain.pem"
  register: cert_exists

- name: Extract SANs from the existing certificate
  shell: >
    openssl x509 -in /etc/letsencrypt/live/{{ inventory_hostname|lower }}/cert.pem -text -noout |
    grep -A 1 "Subject Alternative Name:" |
    tail -n 1 |
    sed 's/DNS://g' |
    tr -d ' ' |
    tr ',' '\n'
  register: existing_sans
  changed_when: false
  when: cert_exists.stat.exists

- set_fact:
    existing_san_list: "{{ existing_sans.stdout_lines }}"
    desired_san_list: "{{ [inventory_hostname|lower] + certbot_additional_sans }}"
  when: cert_exists.stat.exists

- debug:
    var: existing_san_list
  when: cert_exists.stat.exists

- debug:
    var: desired_san_list
  when: cert_exists.stat.exists

- name: Compare existing and desired SANs
  set_fact:
    need_new_cert: "{{ desired_san_list | difference(existing_san_list) | length > 0 }}"
  when: cert_exists.stat.exists

- name: Create dns credentials
  ansible.builtin.template:
    src: dnsprovider.ini.j2
    dest: /tmp/{{ certbot_dns_provider }}.ini
    mode: '0600'
  changed_when: false
  when:
    - certbot_enrollment_type == 'dns_01'
    - certbot_dns_provider is defined

- name: DNS_01 | Request HTTPS certificate if not present
  ansible.builtin.command:
    cmd: "certbot certonly --expand --dns-cloudflare --dns-cloudflare-propagation-seconds 60 --dns-cloudflare-credentials /tmp/cloudflare.ini -d {{ inventory_hostname|lower }}{% for san in certbot_additional_sans %} -d {{ san }}{% endfor %} --register-unsafely-without-email --agree-tos"
  when:
    - not cert_exists.stat.exists or need_new_cert
    - certbot_enrollment_type == 'dns_01'
    - certbot_dns_provider == 'cloudflare'
  register: cert_requested
  notify:
    - check if elasticsearch is active
    - restart elasticsearch
    - wait elasticsearch to be ready
    - check if logstash is active
    - restart logstash
    - check if heartbeat is active
    - reload heartbeat
    - check if filebeat is active
    - reload filebeat
    - check if metricbeat is active
    - reload metricbeat

- name: Remove dns credentials
  ansible.builtin.file:
    path: "/tmp/{{ certbot_dns_provider }}.ini"
    state: absent
  changed_when: false
  when:
    - certbot_enrollment_type == 'dns_01'
    - certbot_dns_provider is defined

- name: HTTP_01 | Request HTTPS certificate if not present
  ansible.builtin.command:
    cmd: "certbot certonly --expand --standalone -d {{ inventory_hostname|lower }} --register-unsafely-without-email --agree-tos"
  when:
    - not cert_exists.stat.exists
    - certbot_enrollment_type == 'http_01'
  register: cert_requested

- name: Local | intermediate exists
  stat:
    path: "{{ elasticsearch_local_certs_dir }}/{{ elasticsearch_ca_intermediate }}"
  register: elastic_intermediate_ca_file
  delegate_to: localhost

- name: Local | root exists
  stat:
    path: "{{ elasticsearch_local_certs_dir }}/ca/{{ elasticsearch_ca_root }}"
  register: elastic_root_ca_file
  delegate_to: localhost

- name: Debug elasticsearch_local_certs_dir
  ansible.builtin.debug:
    msg: "elasticsearch_local_certs_dir value is: {{ elasticsearch_local_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"

- name: Check if the CA file already exists
  ansible.builtin.stat:
    path: "{{ elasticsearch_local_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"
  register: ca_file_stat

- name: Debug ca_file_stat
  debug:
    var: ca_file_stat

- name: Debug SHA256 checksum of local CA file
  debug:
    msg: "{{ lookup('file', elasticsearch_local_certs_dir + '/ca/' + elasticsearch_ca_chain_name) | hash('sha256') }}"
  when: ca_file_stat.stat.exists

- name: Copy remote letsencrypt CA to local files
  fetch:
    src: /etc/letsencrypt/live/{{ inventory_hostname|lower }}/chain.pem
    dest: "{{ elasticsearch_local_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"
    flat: yes
  when: not ca_file_stat.stat.exists or ca_file_stat.stat.checksum != (lookup('file', elasticsearch_local_certs_dir + '/ca/' + elasticsearch_ca_chain_name) | hash('sha256'))
  notify:
    - check if elasticsearch is active
    - restart elasticsearch
    - wait elasticsearch to be ready
  register: fetch_result

- name: Debug fetch result
  debug:
    var: fetch_result
  when: fetch_result is changed

- name: Local | Slurp the chain.pem content
  slurp:
    src: "{{ elasticsearch_local_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"
  register: slurped_chain
  delegate_to: localhost

- name: Local | Decode the chain content
  set_fact:
    chain_content: "{{ slurped_chain['content'] | b64decode | regex_replace('\r\n', '\n') }}"

- name: Local | Split the chain content into individual certificates
  set_fact:
    certificates: "{{ chain_content.split('-----END CERTIFICATE-----') | select('search', 'CERTIFICATE') | list }}"

- name: Local | Write the intermediate certificate to its own file
  copy:
    content: "{{ certificates[0] }}-----END CERTIFICATE-----\n"
    dest: "/tmp/{{ elasticsearch_ca_intermediate }}"
  changed_when: false
  delegate_to: localhost

- name: Local | Copy the intermediate CA file to local certs storage
  ansible.builtin.copy:
    src: "/tmp/{{ elasticsearch_ca_intermediate }}"
    dest: "{{ elasticsearch_local_certs_dir }}/{{ elasticsearch_ca_intermediate }}"
  when:
    - not elastic_intermediate_ca_file.stat.exists or elastic_intermediate_ca_file.stat.checksum != (lookup('file', "/tmp/" + elasticsearch_ca_intermediate) | hash('sha256'))
    - not elasticsearch_ca_intermediate_manually_provided
  delegate_to: localhost

- name: Local | Write the root certificate to its own file
  copy:
    content: "{{ certificates[1] }}-----END CERTIFICATE-----\n"
    dest: "/tmp/{{ elasticsearch_ca_root }}"
  changed_when: false
  delegate_to: localhost

- name: Local | Copy the root CA file to local certs storage
  ansible.builtin.copy:
    src: "/tmp/{{ elasticsearch_ca_root }}"
    dest: "{{ elasticsearch_local_certs_dir }}/ca/{{ elasticsearch_ca_root }}"
  when:
    - not elastic_root_ca_file.stat.exists or (elastic_root_ca_file.stat.exists and elastic_root_ca_file.stat.checksum != (lookup('file', "/tmp/" + elasticsearch_ca_root) | hash('sha256')))
    - not elasticsearch_ca_root_manually_provided
  delegate_to: localhost

- name: Check for missing intermediate certificate
  fail:
    msg: "elasticsearch_ca_intermediate_manually_provided is YES in config file, but root certificate is missing. Please provide it or disable this setting."
  when: 
    - not elastic_intermediate_ca_file.stat.exists
    - not elasticsearch_ca_intermediate_manually_provided

- name: Check for missing root certificate
  fail:
    msg: "elasticsearch_ca_root_manually_provided is YES in config file, but intermediate certificate is missing. Please provide it or disable this setting."
  when: 
    - not elastic_root_ca_file.stat.exists
    - not elasticsearch_ca_root_manually_provided

- name: cert HTTPS exists
  stat:
    path: "{{ elasticsearch_certs_dir}}/http.p12"
  register: https_file

- name: elastic keystore exists
  stat:
    path: "{{ elasticsearch_certs_dir}}/{{ elasticsearch_cert_filename }}"
  register: elastic_keystore_file

- name: elastic CA exists
  stat:
    path: "{{ elasticsearch_certs_dir}}/{{ elasticsearch_ca_filename }}"
  register: ca_file

- name: Get issuer of the http.p12 certificate
  shell: "openssl pkcs12 -in {{ elasticsearch_certs_dir }}/http.p12 -passin pass:{{ elasticsearch_cert_password }} -nokeys -clcerts | openssl x509 -noout -issuer"
  register: https_issuer
  changed_when: false
  ignore_errors: true
  when: https_file.stat.exists and ca_file.stat.exists

- name: Get subject of the CA
  shell: "openssl pkcs12 -in {{ elasticsearch_certs_dir }}/{{ elasticsearch_ca_filename }} -passin pass:{{ elasticsearch_ca_password }} -nokeys -clcerts | openssl x509 -noout -subject"
  register: ca_subject
  changed_when: false
  ignore_errors: true
  when: https_file.stat.exists and ca_file.stat.exists

- name: Set fact for https cert issued by CA
  set_fact:
    https_cert_issued_by_local_ca: "{{ https_issuer.stdout.split('=')[1].strip() == ca_subject.stdout.split('=')[1].strip() }}"
  when: 
    - https_issuer.stdout is defined 
    - ca_subject.stdout is defined

- name: Default https_cert_issued_by_local_ca to false
  set_fact:
    https_cert_issued_by_local_ca: false
  when: https_cert_issued_by_local_ca is undefined

- name: Debug condition variables
  ansible.builtin.debug:
    msg: 
      - "https_cert_issued_by_local_ca: {{ https_cert_issued_by_local_ca }}"
      - "cert_requested.changed: {{ cert_requested.changed }}"
      - "ca_file.stat.exists: {{ ca_file.stat.exists }}"
      - "https_file.stat.exists: {{ https_file.stat.exists }}"

# TODO: below task assumes that the password for both elasticsearch_cert_password and elasticsearch_http_password are the same. May need to split into two PKCS12 files
- name: Create PKCS12 file for new or missing certificates
  ansible.builtin.command:
    cmd: > 
      openssl pkcs12 -export 
      -in /etc/letsencrypt/live/{{ inventory_hostname|lower }}/fullchain.pem
      -inkey /etc/letsencrypt/live/{{ inventory_hostname|lower }}/privkey.pem
      -out /tmp/{{ inventory_hostname|lower }}.p12
      -name elasticsearch -passout pass:{{ elasticsearch_cert_password }}
  when: https_cert_issued_by_local_ca or cert_requested.changed or not https_file.stat.exists or not elastic_keystore_file.stat.exists

- name: Copy new PKCS12 files to Elasticsearch certs directory (node https)
  ansible.builtin.copy:
    src: "/tmp/{{ inventory_hostname|lower }}.p12"
    dest: "{{ elasticsearch_certs_dir }}/{{ elasticsearch_cert_filename }}"
    owner: "{{ elasticsearch_user }}"
    group: "{{ elasticsearch_group }}"
    remote_src: true
    mode: 0644
  when: https_cert_issued_by_local_ca or cert_requested.changed or not elastic_keystore_file.stat.exists
  notify:
    - check if elasticsearch is active
    - restart elasticsearch
    - wait elasticsearch to be ready

- name: Copy new PKCS12 files to Elasticsearch certs directory (client https)
  ansible.builtin.copy:
    src: "/tmp/{{ inventory_hostname|lower }}.p12"
    dest: "{{ elasticsearch_certs_dir }}/http.p12"
    owner: "{{ elasticsearch_user }}"
    group: "{{ elasticsearch_group }}"
    remote_src: true
    mode: 0644
  when: https_cert_issued_by_local_ca or cert_requested.changed or not https_file.stat.exists
  notify:
    - check if elasticsearch is active
    - restart elasticsearch
    - wait elasticsearch to be ready

- name: Clean up temporary PKCS12 files
  ansible.builtin.file:
    path: "/tmp/{{ inventory_hostname|lower }}.p12"
    state: absent

- name: Copy the trusted CA to the elasticsearch config directory
  ansible.builtin.copy:
    src: "{{ elasticsearch_local_certs_dir }}/ca/{{ elasticsearch_ca_chain_name }}"
    dest: "{{ elasticsearch_certs_dir }}/{{ elasticsearch_ca_chain_name }}"

- name: Create certbot post renewal hook
  ansible.builtin.copy:
    content: |
      #!/bin/bash
      DOMAIN=$1

      # Create PKCS12 file
      openssl pkcs12 -export \
        -in /etc/letsencrypt/live/$DOMAIN/fullchain.pem \
        -inkey /etc/letsencrypt/live/$DOMAIN/privkey.pem \
        -out /tmp/$DOMAIN.p12 \
        -name elasticsearch -passout pass:{{ elasticsearch_cert_password }}

      # Copy the PKCS12 file to Elasticsearch certs directory
      echo "Copying certificate to Elasticsearch"
      cp /tmp/$DOMAIN.p12 {{ elasticsearch_certs_dir }}/{{ elasticsearch_cert_filename }}
      cp /tmp/$DOMAIN.p12 {{ elasticsearch_certs_dir }}/http.p12

      if [[ -f "/etc/logstash/certs" ]]; then
        echo "Copying certificate to Logstash"
        cp /etc/letsencrypt/live/$DOMAIN/cert.pem /etc/logstash/certs/{{ elasticsearch_ca_chain_name }}
      fi
      if [[ -f "/etc/kibana/certs" ]]; then
        echo "Copying certificate to Kibana"
        cp /etc/letsencrypt/live/$DOMAIN/cert.pem /etc/kibana/certs/{{ elasticsearch_ca_chain_name }}
      fi

      # Cleanup
      rm -f /tmp/$DOMAIN.p12

      # Restart Elasticsearch service
      systemctl restart elasticsearch
    dest: "/etc/letsencrypt/renewal-hooks/post/elasticsearch-renewal.sh"
    mode: '0755'

# Ensure certbot timer is active and running
- name: Ensure certbot timer is active and running
  ansible.builtin.systemd:
    name: certbot.timer
    state: started
    enabled: true

- name: Local | Cleanup locally created temporary certificates 1/2
  file:
    path: "/tmp/{{ elasticsearch_ca_intermediate }}"
    state: absent
  changed_when: false
  delegate_to: localhost
    
- name: Local | Cleanup locally created temporary certificates 2/2
  file:
    path: "/tmp/{{ elasticsearch_ca_root }}"
    state: absent
  changed_when: false
  delegate_to: localhost

- set_fact:
    https_complete: true